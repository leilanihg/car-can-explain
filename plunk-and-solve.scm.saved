;;; ------------------------------------------------------------------
;;; Copyright 2016 Alexey Radul and Gerald Jay Sussman
;;; ------------------------------------------------------------------
;;; This file is part of New Propagator Prototype.  It is derived from
;;; the Artistic Propagator Prototype previously developed by Alexey
;;; Radul and Gerald Jay Sussman.
;;; 
;;; New Propagator Prototype is free software; you can redistribute it
;;; and/or modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;; 
;;; New Propagator Prototype is distributed in the hope that it will
;;; be useful, but WITHOUT ANY WARRANTY; without even the implied
;;; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
;;; See the GNU General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with New Artistic Propagator Prototype.  If not, see
;;; <http://www.gnu.org/licenses/>.
;;; ------------------------------------------------------------------


(define *debugging-posted* #f)

(define *debugging-equate* #f)

(define *debugging-maybe-post* #f)

(define *debugging-solve* #f)

(define *debugging-general-solve* #f)

(define (plunk! cell)
  (assert (cell? cell) "Can only plunk a cell.")
  (let* ((var (make-plunk-variable (name cell)))
	 (premise (symbol "premise-" var)))
    (eq-put! premise 'premise #t)
    (eq-put! var 'plunk-premise premise)
    (eq-put! premise 'plunk-var var)
    (eq-put! var 'plunk-cell cell)
    (add-content cell
      (make-tms (supported var (list premise))))
    (bring-in! premise)
    (run)))

(define (make-plunk-variable cell-name)
  (set! *plunk-counter* (+ *plunk-counter* 1))
  (string->symbol 
   (string-append
    (fold-left string-append
               ""
               (map symbol->string cell-name))
    "_"
    (number->string *plunk-counter*))))

(define *plunk-counter* 0)

(define (plunk-variable? sym)
  (eq-get sym 'plunk-premise))

;;; A plunk will cause propagation of symbolic expressions.
;;; Eventually these will collide in MERGE, causing EQUATE!  to be
;;; invoked.  This does not create an equation, but it catches obvious
;;; contradictions.

(define *numeric-merge-tolerance* 1e-15)
(define *symbolic-merge-tolerance* 1e-5)

(define (equate! *lhs *rhs)
  (let* ((lhs (g:simplify *lhs)) (rhs (g:simplify *rhs)))
    (if *debugging-equate* (pp `(equate! ,lhs ,rhs)))
    (cond ((equal? lhs rhs)
	   (maybe-symbolic-result lhs))
	  ((and (number? lhs) (number? rhs))
	   (if (default-equal? lhs rhs *numeric-merge-tolerance*)
	       lhs
	       the-contradiction))
	  (else
	   (let ((diff (g:simplify (symb:- lhs rhs))))
	     (if (and (number? diff)
		      (default-equal? diff 0
				      *symbolic-merge-tolerance*))
		 (maybe-symbolic-result
		  (choose-simpler-expression lhs rhs))
		 (let ((vars (plunk-variables diff)))
		   (if (null? vars)
		       the-contradiction
		       (maybe-symbolic-result
			(choose-simpler-expression lhs rhs))))))))))
	      
(assign-operation 'merge equate! abstract-number? abstract-number?)
(assign-operation 'merge equate! number? abstract-number?)
(assign-operation 'merge equate! abstract-number? number?)

(define *equation-residual-tolerance* 1e-7)

(define (maybe-post-equation! v&s-content v&s-answer)
  (let ((*lhs (v&s-value v&s-content))
        (*rhs (v&s-value v&s-answer)))
    (if (or (and (abstract-number? *lhs) (numeric? *rhs))
            (and (abstract-number? *rhs) (numeric? *lhs)))
        (let* ((lhs (g:simplify *lhs))
               (rhs (g:simplify *rhs))
               (diff (g:simplify (symb:- lhs rhs)))
               (residual (if (quotient? diff)
                             (symb:numerator diff)
                             diff)))
          (if *debugging-maybe-post*
              (pp `(maybe-posting ,residual)))
          (if (and (number? residual)
                   (default-equal? residual 0
				   *equation-residual-tolerance*))
              'nothing-to-do
              (let ((unknowns (plunk-variables residual)))
                (if (null? unknowns)
                    the-contradiction
                    (accumulate-equation residual
                                         (merge-supports v&s-content
                                                         v&s-answer)
                                         (merge-reasons  v&s-content
                                                         v&s-answer)
                                         unknowns)))))
	'nothing-to-do)))

;;; Solver equations have just an expression and justifications.
;;; We also put in a reason so we can make an argument.  We combine
;;; the support (premises) with the reason to make an argument.  The
;;; solver will adjoin the arguments of stuff in that slot and when
;;; results come back we have to combine the arguments to make a
;;; correct v&s.

(define (equation-argument supports reasons) 
  (list supports reasons))

(define (argument-supports argument)
  (car argument))

(define (argument-reasons argument)
  (cadr argument))

(define (equation-arguments equation)
  (cadr equation))

(define (accumulate-equation residual supports reasons unknowns)
  (let* ((candidate
          (make-equation residual 
                  (list (equation-argument supports reasons))))
         (new-equation
          (fold-right backsubstitute-equation
                      candidate
                      *substitutions*))
         (new-residual 
          (g:simplify (equation-expression new-equation))))
    (if (number? new-residual)
        (if (default-equal? new-residual 0 
              *equation-residual-tolerance*)
            'nothing-to-do
            the-contradiction)
        (let* ((equation-with-same-residual
                (find (lambda (e)
                        (trivially-equivalent? (equation-expression e)
                                               new-residual))
                      *posted-equations*))
               (new-arguments (equation-arguments new-equation))
               (new-supports (argument-supports new-arguments)))
          (if equation-with-same-residual     ;seen before
              (set! *posted-equations* 
                    (cons 
                     (make-equation
                      new-residual
                      (remove-duplicates
                       (map (lambda (old-argument)
                              (let ((old-supports 
                                     (argument-supports
                                      old-argument)))
                                (if (lset<= new-supports old-supports)
                                    (equation-argument new-supports
                                                       reasons)
                                    old-argument)))
                            (equation-arguments
                             equation-with-same-residual))))
                     (delete equation-with-same-residual
                             *posted-equations*)))
              (set! *posted-equations*
                    (cons (make-equation new-residual new-arguments)
                          *posted-equations*)))
          (if *debugging-posted*
              (pp `(posted ,(car *posted-equations*))))
          'new-equation-posted))))

(define (maybe-solve-equations!)
  (if *debugging-general-solve*
      (pp `(maybe-solve ,*posted-equations*)))
  (set! *posted-equations*
        (sort *posted-equations*
              (lambda (eqn1 eqn2)
                (< (equation-difficulty eqn1)
                   (equation-difficulty eqn2)))))
  (let* ((eqns
	  (filter (lambda (eqn)
		    (any (lambda (just)
			   (every premise-in? (car just)))
			 (equation-justifications eqn)))
		  *posted-equations*))
	 (unknowns
	  (filter plunk-variable?
		  (apply lset-union equal?
			 (map equation-variables eqns)))))
    (if *debugging-general-solve*
	(pp `(to-solver ,eqns ,unknowns)))
    (if (and (not (null? eqns))
	     (not (null? unknowns)))
	(general-solve eqns unknowns
		       use-solutions
		       (lambda () the-contradiction)
		       (lambda () 'cannot-solve-equations))
	'not-enough-equations)))

(define (general-solve eqns unknowns
                       succeed
                       contradiction-failure
                       inadequate-solver-failure)
  (if *debugging-general-solve* (pp `(solving ,eqns ,unknowns)))
  (let ((solution (solve-incremental eqns unknowns)))
    (cond ((symbol? (car solution))
           (case (car solution)
             ((contradictions)
	      (if *debugging-general-solve* (pp 'contradiction-1))
              (contradiction-failure))
             ((failed)
	      (if *debugging-general-solve* (pp solution))
	      (inadequate-solver-failure))
             (else (error "Unknown message from solver" solution))))
          ((and (null? (filter contradictory-equation? ;Paranoia
                               (residual-equations solution)))
                (null? (filter contradictory-equation? ;Paranoia
                               (tough-equations solution))))
	   (if *debugging-general-solve* (pp `(solved ,solution)))
           (let* ((subs (substitutions solution))
                  (renewed-equations
                   (flush-tautologies
                    (map (lambda (eqn)
                           (fold-right backsubstitute-equation
                                       eqn subs))
                         *posted-equations*)))
                  (renewed-substitutions
                   (map (lambda (sub)
                          (fold-right backsubstitute-substitution
                                      sub subs))
                        *substitutions*)))
             (set! *posted-equations*
                   (append renewed-equations
                           (residual-equations solution)))
             (set! *substitutions* 
                   (append renewed-substitutions subs))
             (if *debugging-posted*
                 (pp `(posted-stuff ,*posted-equations*
                                    ,*substitutions*)))
             (succeed subs)))
          (else
	   (if *debugging-general-solve* (pp 'contradiction-2))
	   (contradiction-failure)))))

(define (use-solutions substitution)
  (if *debugging-general-solve* (pp `(using ,substitution)))
  (let* ((now-known-vars
          (map substitution-variable substitution))
         (their-values
          (map substitution-expression substitution))
         (their-justifications
          (map substitution-justifications substitution))
         (premises-to-be-retracted
          (append-map
           (lambda (var val) 
             (if (null? (plunk-variables val))
                 (list (eq-get var 'plunk-premise))
                 '()))
           now-known-vars their-values)))
    (if *debugging-general-solve*
        (pp `(to-be-retracted ,premises-to-be-retracted)))
    (for-each kick-out! premises-to-be-retracted)
    (for-each
     (lambda (var val justs)
       (let ((premises
              (lset-difference eq?
                               (apply lset-union eq? 
                                      (map argument-supports justs))
                               premises-to-be-retracted))
             (reasons
              (lset-adjoin equal?
                           (apply lset-union eq?
                                  (map argument-reasons justs))
                           'solver)))
         (if *debugging-solve*
             (pp `(new-substitution ,var = ,val)))
         (add-content (eq-get var 'plunk-cell)
                      (make-tms
                       (supported (maybe-symbolic-result val)
                                  premises
                                  reasons)))))
     now-known-vars their-values their-justifications)
    ;;(run)
    'done!))

(define (equation-difficulty equation)
  (apply + (map (max-exponent (equation-expression equation))
		(equation-variables equation))))

(define (choose-simpler-expression lhs rhs)
  (cond ((number? lhs) lhs)
        ((number? rhs) rhs)
        (else
         (let ((vlhs (plunk-variables lhs))
               (vrhs (plunk-variables rhs)))
           (let ((elhs (map (max-exponent lhs) vlhs))
                 (erhs (map (max-exponent rhs) vrhs)))
             (let ((wlhs (apply + elhs))
                   (wrhs (apply + erhs)))
               (cond ((< wlhs wrhs) lhs)
                     ((< wrhs wlhs) rhs)
                     (else lhs))))))))

(define ((max-exponent expression) var)
  (let lp ((expr expression))
    (cond ((null? expr) 0)
	  ((equal? expr var) 1)
	  ((expt? expr)
	   (if (equal? (car (operands expr)) var)
	       (cadr (operands expr))
	       0))
	  ((list? expr)
	   (apply max (map lp expr)))
	  (else 0))))


(define (plunk-variables expr)
  (cond ((pair? expr)
         (lset-union eq?
                     (plunk-variables (car expr))
                     (plunk-variables (cdr expr))))
        ((plunk-variable? expr)
         (list expr))
        (else '())))


(define (maybe-symbolic-result expr)
  (if (numeric? expr)
      expr
      (literal-number expr)))

(define (sign-of-abstract-number x)
  (let ((n (g:simplify x)))
    (if (number? n)
        (sign-of-number n)
        nothing)))

(assign-operation 'generic-sign
                  sign-of-abstract-number
                  abstract-number?)

(define (abs-of-abstract-number x)
  (let ((n (g:simplify x)))
    (if (number? n)
        (n:abs n)
        nothing)))

(assign-operation 'abs
                  abs-of-abstract-number
                  abstract-number?)

(define *symbolic-equality-acceptance-tolerance* 1e-4)

(define (symbolic-equal? x y)
  (let ((nx (g:simplify x)) (ny (g:simplify y)))
    (let ((diff (g:simplify (symb:- nx ny))))
      (and (number? diff)
	   (default-equal? diff 0
	     *symbolic-equality-acceptance-tolerance*)))))

(assign-operation 'generic-=
                  symbolic-equal?
                  abstract-number? abstract-number?)

(assign-operation 'generic-=
                  symbolic-equal?
                  number? abstract-number?)
(assign-operation 'generic-=
                  symbolic-equal?
                  abstract-number? number?)

(define (trivially-equivalent? r1 r2)
  (let ((nr1 (g:simplify r1)) (nr2 (g:simplify r2)))
    (or (equal? r1 r2)
	(if (and (number? nr1) (number? nr2))
	    (default-equal? nr1 nr2
			    *equation-residual-tolerance*)
	    (let ((quo (g:simplify (symb:/ nr1 nr2))))
	      (number? quo))))))
