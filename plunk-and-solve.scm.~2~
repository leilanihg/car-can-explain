(define (plunk! cell #!optional var)
  (assert (cell? cell) "Can only plunk a cell.")
  (if (default-object? var)
      (set! var (make-plunk-variable)))
  (assert (symbol? var) "Plunk var must be symbol")
  (let ((premise (symbol "premise-" var)))
    (eq-put! premise 'premise #t)
    (eq-put! var 'plunk-premise premise)
    (eq-put! premise 'plunk-var var)
    (eq-put! var 'plunk-cell cell)
    (add-content cell
      (make-tms (supported var (list premise))))
    (run)))

(define make-plunk-variable (make-new-symbols "plunk-"))

;;; A plunk will cause propagation of symbolic expressions.
;;; Eventually these will collide in MERGE, causing EQUATE! 
;;; to be invoked.

(define (equate! *lhs *rhs)
  (let* ((lhs (g:simplify *lhs))
         (rhs (g:simplify *rhs))
         (residual (g:simplify (symb:- lhs rhs))))
    (if (quotient? residual)
        (set! residual (symb:numerator residual)))
    (if (number? residual)
        (if (generic-zero? residual)
            (maybe-symbolic-result
	     (choose-simpler-expression lhs rhs))
            the-contradiction)
        (let ((vars (plunk-variables residual)))
          (if (null? vars)
              the-contradiction
              (if v&ss-being-merged
                  (post-equation! residual vars lhs rhs)
                  (maybe-symbolic-result
                   (choose-simpler-expression
                    lhs rhs))))))))

(assign-operation 'merge equate!
                  abstract-number? abstract-number?)
(assign-operation 'merge equate!
                  number?         abstract-number?)
(assign-operation 'merge equate!
                  abstract-number?         number?)

;;; The solver needs to track the premises and reasons for each
;;; equation, which are not available here.  So the fluid variable
;;; v&ss-being-merged is set up in supported-values by v&s-merge.

(define (post-equation! residual-expression unknowns lhs rhs)
  (let ((eqn
         (list residual-expression
               (list (list (apply lset-union eq?
                                  (map v&s-support
                                       v&ss-being-merged))
                           (apply lset-union eq?
                                  (map v&s-reasons
                                       v&ss-being-merged))))
               unknowns)))
    (define (accumulate)
      (set! *posted-equations*
            (lset-adjoin
             (lambda (e1 e2)        ; Flush redundancy.
               (let ((r1 (equation-expression e1))
                     (r2 (equation-expression e2)))
                 (trivially-equivalent? r1 r2)))
             *posted-equations*
             eqn))
      (maybe-symbolic-result
       (choose-simpler-expression lhs rhs)))
    (if (= (length unknowns) 1)  ;The easy case first.
        (let ((unk (car unknowns)))
          (solve-one-var eqn unk
            (use-solution-1 (equation-justifications eqn)
                            unk lhs rhs)
            accumulate))
        (let ((other-eqns *posted-equations*)
              (r1 (equation-expression eqn)))
          (if (any (lambda (oe)
                     (let ((r2 (equation-expression oe)))
                       (trivially-equivalent? r1 r2)))
                   other-eqns)
              (maybe-symbolic-result
               (choose-simpler-expression lhs rhs))
              (let ((eqns (cons eqn other-eqns)))
                (if (>= (length eqns) (length unknowns))
                    (general-solve eqns unknowns
                      (use-solutions eqns unknowns lhs rhs)
                      (lambda () the-contradiction))
                    (accumulate))))))))

;;; Exact solution of 1 quasi-linear equation:

(define (solve-one-var-algebraic eqn var succeed fail)
  (isolatable? var eqn succeed fail))

;;; Numerical methods are often better, because floating
;;; point kills symbolic manipulation (polynomial gcd).

(define (solve-one-var-bisection eqn var succeed fail)
  (let ((f (lambda->numerical-procedure
            `(lambda (,var) ,(equation-expression eqn)))))
    (find-a-root f
                 (- root-search-bounds)
                 root-search-bounds
                 root-search-interval
                 bisection-search-tolerance
                 succeed
                 fail)))

(define root-search-bounds 100.0)
(define root-search-interval 0.1)
(define root-search-tolerance 1e-15)

;;; Set this to desired method
(define solve-one-var solve-one-var-algebraic)
;;; (define solve-one-var solve-one-var-bisection)

;;; In any case, gobble up a solution using this method.

(define (use-solution-1 argument var lhs rhs)
  (let ((plunk-premise (eq-get var 'plunk-premise))
        (cell (eq-get var 'plunk-cell)))
    (let ((premises
           (delq plunk-premise
             (apply lset-union eq? (map car argument))))
          (reasons
           (lset-adjoin eq?
             (apply lset-union eq? (map cadr argument))
             'solver)))
      (define (gobble value)
        (let ((val (g:simplify value)))
          (kick-out! plunk-premise)
          (add-content cell
                       (supported
                        (maybe-symbolic-result val)
                        premises reasons))
          (maybe-symbolic-result
           (choose-simpler-expression
            (g:simplify (substitute val var lhs))
            (g:simplify (substitute val var rhs))))))
      gobble)))

;;; The general case for many equations and unknowns

(define (general-solve-symbolic eqns unknowns succeed fail)
  (let ((solution (solve-incremental eqns unknowns)))
    (if (null? (filter contradictory-eqn?
                       (residual-equations solution)))
        (let ((subs (substitutions solution)))
          (succeed (map substitution-variable subs)
                   (map substitution-expression subs)
                   (map substitution-justifications subs)
                   (residual-equations solution)))
        (fail))))

(define (use-solutions eqns unknowns lhs rhs)
  (define (gobble vars values justifications residuals)
    (let ((plunk-premises
           (map (lambda (var)
                  (let ((p (eq-get var 'plunk-premise)))
                    (kick-out! p)
                    p))
                vars)))
      (for-each
       (lambda (var value justification)
         (let ((premises
                (lset-difference eq?
                  (apply lset-union eq?
                         (map car justification))
                  plunk-premises))
               (reasons
                (apply lset-union eq?
                       (map cadr justification))))
           (add-content (eq-get var 'plunk-cell)
             (make-tms
              (supported value premises reasons)))))
       vars values justifications)
      (set! *posted-equations* residuals)
    (let* ((dictionary (map list vars values))
           (lhss (substitute-multiple lhs dictionary))
           (rhss (substitute-multiple rhs dictionary)))
      (maybe-symbolic-result
       (choose-simpler-expression (g:simplify lhss)
                                  (g:simplify rhss))))))
  gobble)

(define general-solve general-solve-symbolic)

;;; Numerical solutions of many equations all depend 
;;; on all of the equations, but symbolic solutions 
;;; may be more discriminating as to dependencies.

(define (general-solve-numerical eqns unknowns succeed fail
             #!optional initial-point initial-step min-step
             tolerance)
  (let ((n (length unknowns))
        (fail (lambda (dismiss) (fail))))
    (assert (>= (length eqns) n) "not enuf equations")
    (if (default-object? initial-point)
        (set! initial-point (make-vector n 1.5)))
    (if (default-object? initial-step)
        (set! initial-step (make-vector n 0.1)))
    (if (default-object? min-step)
        (set! min-step (* 10 n *machine-epsilon*)))
    (if (default-object? tolerance)
        (set! tolerance (* 100 n *machine-epsilon*)))
    (let* ((v (generate-uninterned-symbol 'v))
           (f (lambda->numerical-procedure
               `(lambda (,v)
                  (let ,(map (lambda (unknown i)
                               `(,unknown (vector-ref ,v ,i)))
                             unknowns (iota (length unknowns)))
                    (vector ,@(map equation-expression eqns)))))))
      (multidimensional-root-internal f initial-point
                                      initial-step min-step
        (lambda (proposed-root)
          (let* ((justification
                  (map car (map equation-justifications eqns)))
                 (justifications
                  (map (lambda (unk) justification) unknowns)))
            (let ((value (f proposed-root)))
              (if (< (maxnorm value) tolerance)
                  (succeed unknowns
                           (vector->list proposed-root)
                           justifications
                           '())
                  (fail)))))            ;contradiction failure?
        fail))))                        ;underdetermined failure?
                                        ; Cannot distinguish!

;;; (define general-solve general-solve-numerical)

(define (choose-simpler-expression lhs rhs)
  (cond ((number? lhs) lhs)
        ((number? rhs) rhs)
        (else
         (let ((vlhs (plunk-variables lhs))
               (vrhs (plunk-variables rhs)))
           (let ((elhs (map (max-exponent lhs) vlhs))
                 (erhs (map (max-exponent rhs) vrhs)))
             (let ((wlhs (apply + elhs))
                   (wrhs (apply + erhs)))
               (cond ((< wlhs wrhs) lhs)
                     ((< wrhs wlhs) rhs)
                     (else lhs))))))))

(define ((max-exponent expression) var)
  (let lp ((expr expression))
    (cond ((null? expr) 0)
	  ((expt? expr)
	   (if (equal? (car (operands expr)) var)
	       (cadr (operands expr))
	       0))
	  ((list? expr)
	   (apply max (map lp expr)))
	  (else 0))))

(define (plunk-variable? sym)
  (eq-get sym 'plunk-premise))

(define (plunk-variables expr)
  (cond ((pair? expr)
         (lset-union eq?
                     (plunk-variables (car expr))
                     (plunk-variables (cdr expr))))
        ((plunk-variable? expr)
         (list expr))
        (else '())))


(define (maybe-symbolic-result expr)
  (if (or (number? expr) (symbol? expr))
      expr
      (literal-number expr)))

(define (sign-of-abstract-number x)
  (let ((n (g:simplify x)))
    (if (number? n)
        (sign-of-number n)
        nothing)))

(assign-operation 'generic-sign
                  sign-of-abstract-number
                  abstract-number?)

(define (abs-of-abstract-number x)
  (let ((n (g:simplify x)))
    (if (number? n)
        (n:abs n)
        nothing)))

(assign-operation 'abs
                  abs-of-abstract-number
                  abstract-number?)


(define (symbolic-equal? x y)
  (let ((nx (g:simplify x)) (ny (g:simplify y)))
    (let ((diff (g:simplify (symb:- nx ny))))
      (and (number? diff) (n:= diff 0)))))

(assign-operation 'generic-=
                  symbolic-equal?
                  abstract-number? abstract-number?)

(assign-operation 'generic-=
                  symbolic-equal?
                  number? abstract-number?)
(assign-operation 'generic-=
                  symbolic-equal?
                  abstract-number? number?)

(define (trivially-equivalent? r1 r2)
  (let ((nr1 (g:simplify r1)) (nr2 (g:simplify r2)))
    (let ((quo (g:simplify (symb:/ nr1 nr2))))
      (number? quo))))
