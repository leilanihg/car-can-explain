;;; Crude bias model of common-emitter amplifier.

(initialize-scheduler)

(define TOP (node 'TOP))

(define GND (node 'GND))

(define B (node 'B))

(define C (node 'C))

(define E (node 'E))

(define-cell VThreshold)
(define-cell VSaturation)
(define Q
  ((bjt-crude-bias VThreshold VSaturation 'Q 'active)
   B C E))

(define-cell RB1)
(define RBU ((linear-resistor RB1 'RB1) TOP B))

(define-cell RB2)
(define RBD ((linear-resistor RB2 'RB2) B GND))

(define-cell RC)
(define RPU ((linear-resistor RC 'RC) TOP C))

(define-cell RE)
(define RPD ((linear-resistor RE 'RE) E GND))

(define-cell VCC)
(define VS  ((voltage-source VCC 'VCC) TOP GND))

(cap! TOP)
(cap! GND)
(cap! B)
(cap! C)
(cap! E)

;;; We need a voltage-divider slice!

(define-cell R1+R2)
(define n1 (node 'n1))
(define n2 (node 'n2))

(define Rseries
  ((linear-resistor R1+R2 'Rseries) n1 n2))


;;; Install slice.  
;;; Note: do not cap n1 and n2

(sum RB1 RB2 R1+R2)

(identify-terminals (thing '(t1 RB1))
                    (thing '(t1 Rseries)))

(identify-terminals (thing '(t2 RB2))
                    (thing '(t2 Rseries)))

#|
;;; E96 1% values

(tell! RB2 20000  'gjs3)
(tell! RB1 162000 'gjs4)
(tell! RC  4990   'gjs5)
(tell! RE  1000   'gjs6)


(tell! VThreshold 0.65 'gjs7)		
(tell! VSaturation 0.2 'gjs7)

;;; Unfortunately, floating point kills the equation solver if I plunk!
;;; So:
;;; (tell! VThreshold 65/100 'gjs7)		
;;; (tell! VSaturation 2/10 'gjs7)

(tell! VCC 15 'gjs1)
(tell! (potential GND) 0 'gjs2)

;;; With floating point and a slice
(cpp (inquire (thing '(current c Q))))
#;
((current c Q)
 (has-value 9.983516483523087e-4)
 (because ((- ((i12 Q) (current b Q)) (current c Q))
	   (sum (current b Q) (current c Q) (i12 Q))
	   Q))
 (depends-on (gjs6) (gjs3) (gjs4) (gjs7) (gjs2) (gjs1)))

;;; With  (plunk! (thing '(potential B)))
;;;  (cpp (inquire (thing '(current c Q))))
;;;  #|
;;;  ((current c Q)
;;;   (has-value 1817/1820000)
;;;   (because ((- ((i12 Q) (current b Q)) (current c Q))
;;;	        (sum (current b Q) (current c Q) (i12 Q))
;;;	        Q))
;;;   (depends-on (gjs6) (gjs3) (gjs4) (gjs7) (gjs2) (gjs1)))
;;;  |#

(cpp (inquire (potential (thing '(e Q)))))
#;
((potential E)
 (has-value .9983516483523086)
 (because ((- ((potential B) (v13 Q)) (potential E))
	   (sum (v13 Q) (potential E) (potential B))
	   Q))
 (depends-on (gjs3) (gjs4) (gjs7) (gjs2) (gjs1)))

(retract! 'gjs1)

(cpp (inquire (potential (thing '(e Q)))))
#;
((potential e) (has-value (*the-nothing*)))

(assert! 'gjs1)
;Value: done

(cpp (inquire (potential (thing '(e Q)))))
#;
((potential E)
 (has-value .9983516483523086)
 (because ((- ((potential B) (v13 Q)) (potential E))
	   (sum (v13 Q) (potential E) (potential B))
	   Q))
 (depends-on (gjs3) (gjs4) (gjs7) (gjs2) (gjs1)))

(retract! 'gjs5)

(cpp (inquire (potential (thing '(b Q)))))
#;
((potential B)
 (has-value 150/91)
 (because ((- ((potential TOP) (v RB1)) (potential B))
	   (sum (v RB1) (potential B) (potential TOP))
	   RB1))
 (depends-on (gjs4) (gjs3) (gjs2) (gjs1)))

(cpp (inquire (potential (thing '(c Q)))))
#;
((potential c) (has-value (*the-nothing*)))

(tell! RC 15000 'gjs8)
;contradiction #[compound-procedure 272 me] (gjs8 gjs6 gjs7 gjs4 gjs3 ...)

(retract! 'gjs8)

(tell! RC 10000 'gjs9)

(cpp (inquire (potential (thing '(c Q)))))
#;
((potential C)
 (has-value 5.016483516476914)
 (because ((- ((potential TOP) (v RC)) (potential C))
	   (sum (v RC) (potential C) (potential TOP))
	   RC))
 (depends-on (gjs9) (gjs6) (gjs3) (gjs4) (gjs7) (gjs2) (gjs1)))

(retract! 'gjs9)
;Value: done

(tell! RC 13900 'gjs10)
;Value: done

(cpp (inquire (potential (thing '(c Q)))))
#;
((potential C)
 (has-value 1.1229120879029093)
 (because ((- ((potential TOP) (v RC)) (potential C))
	   (sum (v RC) (potential C) (potential TOP))
	   RC))
 (depends-on (gjs10) (gjs6) (gjs3) (gjs4) (gjs7) (gjs2) (gjs1)))

(cpp (inquire (potential (thing '(e Q)))))
#;
((potential E)
 (has-value .9983516483523086)
 (because ((- ((potential B) (v13 Q)) (potential E))
	   (sum (v13 Q) (potential E) (potential B))
	   Q))
 (depends-on (gjs3) (gjs4) (gjs7) (gjs2) (gjs1)))
|#
;;;-------------------------------------------------------

;;; Now, let the transistor decide the state

(initialize-scheduler)

(define TOP (node 'TOP))

(define GND (node 'GND))

(define B (node 'B))

(define C (node 'C))

(define E (node 'E))

(define-cell VThreshold)
(define-cell VSaturation)
(define Q
  ((bjt-crude-bias VThreshold VSaturation 'Q)
   B C E))

(define-cell RB1)
(define RBU ((linear-resistor RB1 'RB1) TOP B))

(define-cell RB2)
(define RBD ((linear-resistor RB2 'RB2) B GND))

(define-cell RC)
(define RPU ((linear-resistor RC 'RC) TOP C))

(define-cell RE)
(define RPD ((linear-resistor RE 'RE) E GND))

(define-cell VCC)
(define VS  ((voltage-source VCC 'VCC) TOP GND))

(cap! TOP)
(cap! GND)
(cap! B)
(cap! C)
(cap! E)

;;; We need a voltage-divider slice!

(define-cell R1+R2)
(define n1 (node 'n1))
(define n2 (node 'n2))

(define Rseries
  ((linear-resistor R1+R2 'Rseries) n1 n2))


;;; Install slice.  
;;; Note: do not cap n1 and n2

(sum RB1 RB2 R1+R2)

(identify-terminals (thing '(t1 RB1))
                    (thing '(t1 Rseries)))

(identify-terminals (thing '(t2 RB2))
		    (thing '(t2 Rseries)))

#|
;;; E96 1% values

(tell! RB2 20000  'gjs3)
(tell! RB1 162000 'gjs4)
(tell! RC  4990   'gjs5)
(tell! RE  1000   'gjs6)

(tell! VThreshold 0.65 'gjs7)
(tell! VSaturation 0.2 'gjs7)

(tell! VCC 15 'gjs1)
(tell! (potential GND) 0 'gjs2)

(cpp (inquire (current (thing '(c Q)))))
#;
((current c Q)
 (has-value 9.983516483516482e-4)
 (because ((- ((i12 Q) (current b Q)) (current c Q))
	   (sum (current b Q) (current c Q) (i12 Q))
	   Q))
 (depends-on (gjs6) (hypothetical) (gjs7) (gjs4) (gjs3) (gjs2) (gjs1)))

;;; now depends on hypothetical

(name (hypothetical-amb-cell (cadr (v&s-support (tms-query (content (thing '(current c Q))))))))
;Value: (active Q)

(cpp (inquire (thing '(active Q))))
#;
((active Q)
 (has-value #t)
 (because ((binary-amb (active Q)) Q))
 (depends-on (#(hypothetical #[compound-procedure 324 ...]))))

(retract! 'gjs5)

(cpp (inquire (thing '(current c Q))))
#; unchanged, because did not depend on gjs5

(tell! RC 15000 'gjs8)

(cpp (inquire (thing '(active Q))))
#;
((active Q)
 (has-value #f)
 (because ((binary-amb (active Q)) Q))
 (depends-on (#(hypothetical #[compound-procedure 324 ...]))))

(cpp (inquire (thing '(saturated Q))))
#;
((saturated Q) (has-value #t)
 (because
  ((function-propagator (ro) ((cvs Q) (cutoff Q)) (saturated Q))
   (disjunction (cutoff Q) (saturated Q) (cvs Q))
   Q))
 (depends-on (#(hypothetical #[compound-procedure 312 ...]))
	     (#(hypothetical #[compound-procedure 325 ...]))))

(cpp (inquire (thing '(cutoff Q))))
#;
((cutoff Q) (has-value #f)
            (because ((binary-amb (cutoff Q)) Q))
            (depends-on (#(hypothetical #[compound-procedure 312 ...]))))

(retract! 'gjs3)

(tell! RB2 1000 'gjs9)

(cpp (inquire (thing '(cutoff Q))))
#;
((cutoff Q)
 (has-value #t)
 (because ((binary-amb (cutoff Q)) Q))
 (depends-on (#(hypothetical #[compound-procedure 325 ...]))))

(cpp (inquire (thing '(active Q))))
#;
((active Q)
 (has-value #f)
 (because ((function-propagator (>) ((absic Q) (zeroi Q)) (active Q)) Q))
 (depends-on (#(hypothetical #[compound-procedure 325 ...]))))

(cpp (inquire (thing '(saturated Q))))
#;
((saturated Q)
 (has-value (*the-nothing*))
 (because ((function-propagator (pmi) ((cvs Q)) (saturated Q))
	   (disjunction (cutoff Q) (saturated Q) (cvs Q))
	   Q))
 (depends-on (#(hypothetical #[compound-procedure 324 ...]))))
|#
