;;; ------------------------------------------------------------------
;;; Copyright 2016 Alexey Radul and Gerald Jay Sussman
;;; ------------------------------------------------------------------
;;; This file is part of New Propagator Prototype.  It is derived from
;;; the Artistic Propagator Prototype previously developed by Alexey
;;; Radul and Gerald Jay Sussman.
;;; 
;;; New Propagator Prototype is free software; you can redistribute it
;;; and/or modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;; 
;;; New Propagator Prototype is distributed in the hope that it will
;;; be useful, but WITHOUT ANY WARRANTY; without even the implied
;;; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
;;; See the GNU General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with New Artistic Propagator Prototype.  If not, see
;;; <http://www.gnu.org/licenses/>.
;;; ------------------------------------------------------------------


(define *debugging-solve* #f)

(define *debugging-general-solve* #f)

(define (plunk! cell)
  (assert (cell? cell) "Can only plunk a cell.")
  (let* ((var (make-plunk-variable (name cell)))
	 (premise (symbol "premise-" var)))
    (eq-put! premise 'premise #t)
    (eq-put! var 'plunk-premise premise)
    (eq-put! premise 'plunk-var var)
    (eq-put! var 'plunk-cell cell)
    (add-content cell
      (make-tms (supported var (list premise))))
    (run)))

(define (plunk-variable-maker)
  (let ((plunk-counter 0))
    (define (make-plunk-variable cell-name)
      (set! plunk-counter (+ plunk-counter 1))
      (string->symbol 
       (string-append
	(fold-left string-append
		   ""
		   (map symbol->string cell-name))
	"_"
	(number->string plunk-counter))))
    make-plunk-variable))

(define make-plunk-variable (plunk-variable-maker))

;;; A plunk will cause propagation of symbolic expressions.
;;; Eventually these will collide in MERGE, causing EQUATE!  to be
;;; invoked.  This does not create an equation, but it catches obvious
;;; contradictions.

(define *numeric-merge-tolerance* 1e-15)
(define *symbolic-merge-tolerance* 1e-5)

(define (equate! *lhs *rhs)
  (let* ((lhs (g:simplify *lhs)) (rhs (g:simplify *rhs)))
    (if *debugging-solve* (pp `(equate! ,lhs ,rhs)))
    (cond ((equal? lhs rhs)
	   (maybe-symbolic-result lhs))
	  ((and (number? lhs) (number? rhs))
	   (if (default-equal? lhs rhs *numeric-merge-tolerance*)
	       lhs
	       the-contradiction))
	  (else
	   (let ((diff (g:simplify (symb:- lhs rhs))))
	     (if (and (number? diff)
		      (default-equal? diff 0
				      *symbolic-merge-tolerance*))
		 (maybe-symbolic-result
		  (choose-simpler-expression lhs rhs))
		 (let ((vars (plunk-variables diff)))
		   (if (null? vars)
		       the-contradiction
		       (maybe-symbolic-result
			(choose-simpler-expression lhs rhs))))))))))
	      
(assign-operation 'merge equate! abstract-number? abstract-number?)
(assign-operation 'merge equate! number? abstract-number?)
(assign-operation 'merge equate! abstract-number? number?)

(define *equation-residual-tolerance* 1e-7)

(define (maybe-post-equation! v&s-content v&s-answer)
  (let ((*lhs (v&s-value v&s-content))
        (*rhs (v&s-value v&s-answer)))
    (if (or (and (abstract-number? *lhs) (numeric? *rhs))
            (and (abstract-number? *rhs) (numeric? *lhs)))
        (let* ((lhs (g:simplify *lhs))
               (rhs (g:simplify *rhs))
               (diff (g:simplify (symb:- lhs rhs)))
               (residual (if (quotient? diff)
                             (symb:numerator diff)
                             diff)))
          (if *debugging-solve*
              (pp `(maybe-posting ,residual)))
          (if (and (number? residual)
                   (default-equal? residual 0
				   *equation-residual-tolerance*))
              'nothing-to-do
              (let ((unknowns (plunk-variables residual)))
                (if (null? unknowns)
                    the-contradiction
                    (accumulate-equation residual
                                         (merge-supports v&s-content
                                                         v&s-answer)
                                         (merge-reasons  v&s-content
                                                         v&s-answer)
                                         unknowns)))))
	'nothing-to-do)))

(define (accumulate-equation residual supports reasons unknowns)
  (if *debugging-solve*
      (pp `(posting ,residual)))
  (let ((equation-with-same-residual
         (find (lambda (e)
                 (trivially-equivalent? (equation-expression e)
                                        residual))
               *posted-equations*)))
    (if equation-with-same-residual     ;seen before
        (if (lset< eq?                  
                   supports             ;more informative
                   (caaadr equation-with-same-residual))
            (set-car! (cadr equation-with-same-residual)
                      (list supports reasons))
            'nothing-to-do)
        (set! *posted-equations*
              (cons (list residual
                          (list (list supports reasons))
                          unknowns)
                    *posted-equations*)))))

(define (maybe-solve-equations!)
  (if *debugging-general-solve*
      (pp `(maybe-solve ,*posted-equations*)))
  (set! *posted-equations*
        (sort *posted-equations*
              (lambda (eqn1 eqn2)
                (< (equation-difficulty eqn1)
                   (equation-difficulty eqn2)))))
  (let* ((eqns
	  (filter (lambda (eqn)
		    (any (lambda (just)
			   (every premise-in? (car just)))
			 (equation-justifications eqn)))
		  *posted-equations*))
	 (unknowns
	  (apply lset-union equal?
		 (map equation-variables eqns))))
    (if *debugging-general-solve*
	(pp `(to-solver ,eqns ,unknowns)))
    (if (and (not (null? eqns))
	     (not (null? unknowns)))
	(general-solve eqns unknowns
		       (use-solutions eqns unknowns)
		       (lambda () the-contradiction)
		       (lambda () 'cannot-solve-equations))
	'not-enough-equations)
    ))

;;; The general case for many equations and unknowns

(define (general-solve-symbolic eqns unknowns
                                succeed
                                contradiction-failure
                                inadequate-solver-failure)
  (if *debugging-general-solve* (pp `(solving ,eqns ,unknowns)))
  (let ((solution (solve-incremental eqns unknowns)))
    (cond ((symbol? (car solution))
           (case (car solution)
             ((contradictions)
	      (if *debugging-general-solve* (pp 'contradiction-1))
              (contradiction-failure))
             ((failed)
	      (if *debugging-general-solve* (pp solution))
	      (inadequate-solver-failure))
             (else (error "Unknown message from solver" solution))))
          ((and (null? (filter contradictory-equation? ;Paranoia
                               (residual-equations solution)))
                (null? (filter contradictory-equation? ;Paranoia
                               (tough-equations solution))))
	   (if *debugging-general-solve* (pp `(solved ,solution)))
           (let ((subs (substitutions solution)))
	     (let ((result (succeed subs)))
	       (set! *posted-equations*
		     (append
		      (flush-tautologies
		       (map (lambda (eqn)
			      (apply-substitutions-to-equation eqn subs))
			    *posted-equations*))
		      (residual-equations solution)))
	       result)))
          (else
	   (if *debugging-general-solve* (pp 'contradiction-2))
	   (contradiction-failure)))))

(define (use-solutions equations unknowns)
  (define (gobble substitution)
    (if *debugging-general-solve* (pp `(using ,substitution)))
    (let* ((now-known-vars
	    (map substitution-variable substitution))
	   (their-values
	    (map substitution-expression substitution))
	   (their-justifications
	    (map substitution-justifications substitution))
	   (premises-to-be-retracted
	    (append-map
	     (lambda (var val)
	       (if (null? (plunk-variables val))
		   (list (eq-get var 'plunk-premise))
		   '()))
	     now-known-vars their-values)))

      (if *debugging-general-solve*
	  (pp `(to-be-retracted ,premises-to-be-retracted)))

      (for-each kick-out! premises-to-be-retracted)

      (for-each
       (lambda (var val just)
	 (let ((premises
		(lset-difference eq?
				 (apply lset-union eq? (map car just))
				 premises-to-be-retracted))
	       (reasons
		(lset-adjoin eq?
			     (apply lset-union eq? (map cadr just))
			     'solver)))
	   (if *debugging-solve* (pp `(solved ,var = ,val)))
	   (add-content (eq-get var 'plunk-cell)
			(make-tms
			 (supported (maybe-symbolic-result val)
				    premises
				    reasons)))))
       now-known-vars their-values their-justifications)

      (run)

      (if *debugging-solve*
	  (pp `(new-posts ,*posted-equations*)))
      'done!))
  gobble)

(define general-solve general-solve-symbolic)

(define (equation-difficulty equation)
  (apply + (map (max-exponent (equation-expression equation))
		(equation-variables equation))))

(define (choose-simpler-expression lhs rhs)
  (cond ((number? lhs) lhs)
        ((number? rhs) rhs)
        (else
         (let ((vlhs (plunk-variables lhs))
               (vrhs (plunk-variables rhs)))
           (let ((elhs (map (max-exponent lhs) vlhs))
                 (erhs (map (max-exponent rhs) vrhs)))
             (let ((wlhs (apply + elhs))
                   (wrhs (apply + erhs)))
               (cond ((< wlhs wrhs) lhs)
                     ((< wrhs wlhs) rhs)
                     (else lhs))))))))

(define ((max-exponent expression) var)
  (let lp ((expr expression))
    (cond ((null? expr) 0)
	  ((equal? expr var) 1)
	  ((expt? expr)
	   (if (equal? (car (operands expr)) var)
	       (cadr (operands expr))
	       0))
	  ((list? expr)
	   (apply max (map lp expr)))
	  (else 0))))

(define (plunk-variable? sym)
  (eq-get sym 'plunk-premise))

(define (plunk-variables expr)
  (cond ((pair? expr)
         (lset-union eq?
                     (plunk-variables (car expr))
                     (plunk-variables (cdr expr))))
        ((plunk-variable? expr)
         (list expr))
        (else '())))


(define (maybe-symbolic-result expr)
  (if (numeric? expr)
      expr
      (literal-number expr)))

(define (sign-of-abstract-number x)
  (let ((n (g:simplify x)))
    (if (number? n)
        (sign-of-number n)
        nothing)))

(assign-operation 'generic-sign
                  sign-of-abstract-number
                  abstract-number?)

(define (abs-of-abstract-number x)
  (let ((n (g:simplify x)))
    (if (number? n)
        (n:abs n)
        nothing)))

(assign-operation 'abs
                  abs-of-abstract-number
                  abstract-number?)

(define *symbolic-equality-acceptance-tolerance* 1e-4)

(define (symbolic-equal? x y)
  (let ((nx (g:simplify x)) (ny (g:simplify y)))
    (let ((diff (g:simplify (symb:- nx ny))))
      (and (number? diff)
	   (default-equal? diff 0
	     *symbolic-equality-acceptance-tolerance*)))))

(assign-operation 'generic-=
                  symbolic-equal?
                  abstract-number? abstract-number?)

(assign-operation 'generic-=
                  symbolic-equal?
                  number? abstract-number?)
(assign-operation 'generic-=
                  symbolic-equal?
                  abstract-number? number?)

(define (trivially-equivalent? r1 r2)
  (let ((nr1 (g:simplify r1)) (nr2 (g:simplify r2)))
    (or (equal? r1 r2)
	(if (and (number? nr1) (number? nr2))
	    (default-equal? nr1 nr2
			    *equation-residual-tolerance*)
	    (let ((quo (g:simplify (symb:/ nr1 nr2))))
	      (number? quo))))))
